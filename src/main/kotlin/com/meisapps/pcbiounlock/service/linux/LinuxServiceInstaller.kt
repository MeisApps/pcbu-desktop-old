package com.meisapps.pcbiounlock.service.linux

import com.meisapps.pcbiounlock.service.ServiceInstaller
import com.meisapps.pcbiounlock.shell.Shell
import com.meisapps.pcbiounlock.storage.AppSettings
import com.meisapps.pcbiounlock.natives.LinuxUtils
import com.meisapps.pcbiounlock.utils.ErrorMessageException
import com.meisapps.pcbiounlock.utils.io.Console
import com.meisapps.pcbiounlock.utils.io.IOUtils
import com.meisapps.pcbiounlock.utils.io.ResourceHelper
import com.meisapps.pcbiounlock.utils.io.ResourceHelper.LinuxCryptoFileName
import com.meisapps.pcbiounlock.utils.io.ResourceHelper.LinuxSSLFileName
import com.meisapps.pcbiounlock.utils.io.ResourceHelper.PamModuleFileName
import com.meisapps.pcbiounlock.utils.io.ResourceHelper.PcbuAuthFileName
import com.meisapps.pcbiounlock.utils.text.I18n
import java.io.BufferedReader
import java.io.File
import java.io.FileReader

class LinuxServiceInstaller(private val shell: Shell) : ServiceInstaller() {
    companion object {
        const val PamConfigLineEntry = "auth sufficient pam_pcbiounlock.so"
        const val PamSddmLineEntry = "auth [success=1 new_authtok_reqd=1 default=ignore] pam_unix.so try_first_pass likeauth nullok\nauth sufficient pam_pcbiounlock.so"

        const val PamConfigGeneratedEntry = "## Generated by PC Bio Unlock"
        val PamConfigGeneratedCommon = """
            #%PAM-1.0
            $PamConfigLineEntry
            $PamConfigGeneratedEntry
            
            auth include common-auth
            account include common-account
            password include common-password
            session include common-session
        """.trimIndent()
        val PamConfigGeneratedSystem = """
            #%PAM-1.0
            $PamConfigLineEntry
            $PamConfigGeneratedEntry
            
            auth include system-auth
            account include system-auth
            password include system-auth
            session include system-auth
        """.trimIndent()
    }

    override fun getModulePath(): String {
        val dirs = LinuxUtils.getPamModuleDirs()
        return dirs[0] + PamModuleFileName
    }

    override fun isInstalled() : Boolean {
        for(moduleDir in LinuxUtils.getPamModuleDirs()) {
            val filePath = moduleDir + PamModuleFileName
            if (File(filePath).exists())
                return isOpenSSLInstalled() && File("/usr/sbin/$PcbuAuthFileName").exists()
        }
        return false
    }

    override fun installOpenSSL() {
        throw ErrorMessageException(I18n.get("error_linux_required_dep", "OpenSSL 3"))
    }

    override fun doInstall() {
        val settings = AppSettings.get()

        Console.println("Copying binary module...")
        shell.writeBytes("/usr/sbin/$PcbuAuthFileName", ResourceHelper.getNativeByName(PcbuAuthFileName))
        if(shell.runCommand("chmod +x /usr/sbin/$PcbuAuthFileName && chmod u+s /usr/sbin/$PcbuAuthFileName").exitCode != 0)
            throw Exception("Failed to set uid permissions !")

        Console.println("Copying PAM module...")
        shell.runCommand("mkdir /lib/security")
        val pamData = ResourceHelper.getNativeByName(PamModuleFileName)
        for(moduleDir in LinuxUtils.getPamModuleDirs()) {
            if(!File(moduleDir).exists())
                continue

            shell.writeBytes("$moduleDir/$PamModuleFileName", pamData)
        }

        if(isUfwInstalled()) {
            Console.println("Adding firewall rules (ufw)...")
            val fwResult = //shell.runCommand("ufw allow ${settings.unlockServerPort}/tcp").exitCode == 0 &&
                            shell.runCommand("ufw allow ${settings.pairingServerPort}/tcp").exitCode == 0
            if(!fwResult)
                Console.println("Failed to add firewall rules !")
        }
        if(isFirewalldInstalled()) {
            Console.println("Adding firewall rules (firewalld)...")
            val fwResult = //shell.runCommand("firewall-cmd --zone=public --add-port=${settings.unlockServerPort}/tcp --permanent").exitCode == 0 &&
                    shell.runCommand("firewall-cmd --zone=public --add-port=${settings.pairingServerPort}/tcp --permanent").exitCode == 0 &&
                    shell.runCommand("firewall-cmd --reload").exitCode == 0
            if(!fwResult)
                Console.println("Failed to add firewall rules !")
        }

        Console.println("Enabling sudo integration...")
        setSudoEnabled(true)
    }

    override fun doUninstall(fullUninstall: Boolean) {
        val settings = AppSettings.get()

        Console.println("Removing binary module...")
        if(shell.runCommand("rm /usr/sbin/$PcbuAuthFileName").exitCode != 0)
            Console.println("Failed to remove binary module !")

        Console.println("Removing PAM module...")
        for(moduleDir in LinuxUtils.getPamModuleDirs()) {
            val filePath = moduleDir+ PamModuleFileName
            if(!File(filePath).exists())
                continue

            if(shell.runCommand("rm \"$filePath\"").exitCode != 0)
                throw Exception("Failed to remove PAM module !")
        }

        if(isUfwInstalled()) {
            Console.println("Removing firewall rules (ufw)...")
            val fwResult = //shell.runCommand("ufw delete allow ${settings.unlockServerPort}/tcp").exitCode == 0 &&
                    shell.runCommand("ufw delete allow ${settings.pairingServerPort}/tcp").exitCode == 0
            if(!fwResult)
                Console.println("Failed to delete firewall rules !")
        }
        if(isFirewalldInstalled()) {
            Console.println("Removing firewall rules (firewalld)...")
            val fwResult = //shell.runCommand("firewall-cmd --zone=public --remove-port=${settings.unlockServerPort}/tcp --permanent").exitCode == 0 &&
                    shell.runCommand("firewall-cmd --zone=public --remove-port=${settings.pairingServerPort}/tcp --permanent").exitCode == 0 &&
                    shell.runCommand("firewall-cmd --reload").exitCode == 0
            if(!fwResult)
                Console.println("Failed to delete firewall rules !")
        }

        if(fullUninstall) {
            Console.println("Disabling integrations...")
            setSudoEnabled(false)
            setPolkitEnabled(false)
            setLoginManagerEnabled(false)
        } else {
            // Apply integrations again in case of reinstall
            setSudoEnabled(!isSudoEnabled())
            setPolkitEnabled(!isPolkitEnabled())
            setLoginManagerEnabled(!isLoginManagerEnabled())
            setSudoEnabled(!isSudoEnabled())
            setPolkitEnabled(!isPolkitEnabled())
            setLoginManagerEnabled(!isLoginManagerEnabled())
        }
    }

    override fun isOpenSSLInstalled(): Boolean {
        return LinuxUtils.hasSharedLibrary(LinuxCryptoFileName) &&
                LinuxUtils.hasSharedLibrary(LinuxSSLFileName)
    }

    private fun isUfwInstalled(): Boolean {
        return shell.runUserCommand("which ufw").exitCode == 0
    }

    private fun isFirewalldInstalled(): Boolean {
        return shell.runUserCommand("which firewall-cmd").exitCode == 0
    }

    fun isGdmInstalled(): Boolean {
        return shell.runUserCommand("systemctl cat gdm").exitCode == 0 || shell.runUserCommand("which gdm").exitCode == 0
    }

    fun isSddmInstalled(): Boolean {
        return shell.runUserCommand("systemctl cat sddm").exitCode == 0 || shell.runUserCommand("which sddm").exitCode == 0
    }

    fun isKdeInstalled(): Boolean {
        return shell.runUserCommand("which kdeinit5").exitCode == 0 || shell.runUserCommand("which kde-open").exitCode == 0
    }

    fun isLightdmInstalled(): Boolean {
        return shell.runUserCommand("systemctl cat lightdm").exitCode == 0 || shell.runUserCommand("which lightdm").exitCode == 0
    }

    fun isCinnamonInstalled(): Boolean {
        return shell.runUserCommand("which cinnamon").exitCode == 0
    }

    fun isSudoEnabled() : Boolean {
        val sudoConfig = getPamConfigFile("sudo")
        return IOUtils.findLine(sudoConfig, PamConfigLineEntry)
    }

    fun isPolkitEnabled() : Boolean {
        val sudoConfig = getPamConfigFile("polkit-1")
        return IOUtils.findLine(sudoConfig, PamConfigLineEntry)
    }

    fun isLoginManagerEnabled() : Boolean {
        val gdmConfig = getPamConfigFile("gdm-password")
        val sddmConfig = getPamConfigFile("sddm")
        val kdeConfig = getPamConfigFile("kde")
        val lightdmConfig = getPamConfigFile("lightdm")
        val cinnamonConfig = getPamConfigFile("cinnamon-screensaver")
        return IOUtils.findLine(gdmConfig, PamConfigLineEntry) ||
                IOUtils.findLine(kdeConfig, PamConfigLineEntry) ||
                sddmConfig.exists() && sddmConfig.readText().contains(PamSddmLineEntry) ||
                IOUtils.findLine(lightdmConfig, PamConfigLineEntry) ||
                IOUtils.findLine(cinnamonConfig, PamConfigLineEntry)
    }

    fun setSudoEnabled(enabled: Boolean) {
        val isEnabled = isSudoEnabled();
        if(enabled && isEnabled || !enabled && !isEnabled)
            return

        val sudoConfig = getPamConfigFile("sudo")
        if(enabled) {
            generateConfig(sudoConfig, PamConfigLineEntry)
        } else {
            deleteConfig(sudoConfig, PamConfigLineEntry)
        }
    }

    fun setPolkitEnabled(enabled: Boolean) {
        val isEnabled = isPolkitEnabled();
        if(enabled && isEnabled || !enabled && !isEnabled)
            return

        val polkitConfig = getPamConfigFile("polkit-1")
        if(enabled) {
            generateConfig(polkitConfig, PamConfigLineEntry)
        } else {
            deleteConfig(polkitConfig, PamConfigLineEntry)
        }
    }

    fun setLoginManagerEnabled(enabled: Boolean) {
        val isEnabled = isLoginManagerEnabled();
        if(enabled && isEnabled || !enabled && !isEnabled)
            return

        if(isGdmInstalled()) {
            val gdmConfig = getPamConfigFile("gdm-password")
            if(enabled) {
                generateConfig(gdmConfig, PamConfigLineEntry)
            } else {
                deleteConfig(gdmConfig, PamConfigLineEntry)
            }
        }

        if(isSddmInstalled()) {
            val sddmConfig = getPamConfigFile("sddm")
            if(enabled) {
                generateConfig(sddmConfig, PamSddmLineEntry)
            } else {
                deleteConfig(sddmConfig, PamSddmLineEntry)
            }
        }

        if(isKdeInstalled()) {
            val kdeConfig = getPamConfigFile("kde")
            if(enabled) {
                generateConfig(kdeConfig, PamConfigLineEntry)
            } else {
                deleteConfig(kdeConfig, PamConfigLineEntry)
            }
        }

        if(isLightdmInstalled()) {
            val config = getPamConfigFile("lightdm")
            if(enabled) {
                generateConfig(config, PamConfigLineEntry)
            } else {
                deleteConfig(config, PamConfigLineEntry)
            }
        }

        if(isCinnamonInstalled()) {
            val config = getPamConfigFile("cinnamon-screensaver")
            if(enabled) {
                generateConfig(config, PamConfigLineEntry)
            } else {
                deleteConfig(config, PamConfigLineEntry)
            }
        }
    }

    private fun getPamConfigFile(name: String): File {
        val configPath = LinuxUtils.getPamConfigDir() + name
        return File(configPath)
    }

    private fun generateConfig(file: File, line: String) {
        if(!file.exists()) {
            Console.println("Generating configuration ${file.absolutePath}...")

            val hasCommonAuth = getPamConfigFile("common-auth").exists()
            val hasSystemAuth = getPamConfigFile("system-auth").exists()
            if(hasSystemAuth) {
                shell.writeBytes(file.absolutePath, PamConfigGeneratedSystem.toByteArray(Charsets.UTF_8))
            } else {
                shell.writeBytes(file.absolutePath, PamConfigGeneratedCommon.toByteArray(Charsets.UTF_8))
            }

            if(!hasCommonAuth && !hasSystemAuth)
                Console.println("Warning: PAM configuration unknown. Please report on GitHub.")
        } else {
            addLineToFile(file, line)
        }
    }

    private fun deleteConfig(file: File, line: String) {
        if(!file.exists())
            return

        if(isConfigFileGenerated(file)) {
            Console.println("Deleting configuration ${file.absolutePath}...")
            shell.runCommand("rm ${file.absolutePath}")
        } else {
            removeLineFromFile(file, line)
        }
    }

    private fun isConfigFileGenerated(file: File) : Boolean {
        return IOUtils.findLine(file, PamConfigGeneratedEntry)
    }

    private fun addLineToFile(file: File, lineStr: String) {
        if(!file.exists())
            return

        val containsBegin = IOUtils.findLine(file, "#%PAM-1.0")
        var fileText = ""
        val reader = BufferedReader(FileReader(file))
        if(!containsBegin) {
            fileText += "#%PAM-1.0" + "\n"
            fileText += lineStr + "\n"
        }

        while(true) {
            val line = reader.readLine() ?: break
            if(line == "#%PAM-1.0" && containsBegin) {
                fileText += line + "\n"
                fileText += lineStr + "\n"
            } else {
                fileText += line + "\n"
            }
        }
        shell.writeBytes(file.absolutePath, fileText.toByteArray(Charsets.UTF_8))
    }

    private fun removeLineFromFile(file: File, lineStr: String) {
        if(!file.exists())
            return

        var fileText = file.readText()
        fileText = fileText.replace(lineStr, "")
        shell.writeBytes(file.absolutePath, fileText.toByteArray(Charsets.UTF_8))
    }
}
